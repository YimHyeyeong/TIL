## 최소 신장 트리(MST)

* 그래프에서 최소 비용 문제
  1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  2. 두 정점 사이의 최소 비용의 경로 찾기
* 신장 트리
  * n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어짐 트리
* 최소 신장 트리(Minimum Spanning Tree)
  * 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리





## Prim 알고리즘

* 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 `MST`를 만들어 가는 방식
  1. 임의 정점을 하나 선택해서 시작
  2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  3. 모든 정점이 선택될 때 까지 1,2 과정을 반복
* 서로소인 2개의 집합 정보를 유지
  * 트리 정점들 - `MST` 를 만들기 위해 선택된 정점들
  * 비트리 정점들 - 선택 되지 않은 정점들

![image-20211218150037075](03_최소신장트리(MST).assets/image-20211218150037075.png)

* 남은 정점이 있으면 MST에 속한 정점 v, MST에 속하지 않고 비용가주이가 최소인 인접 w를 선택

```
6 11
0 1 32
0 2 31
0 5 60
0 6 51
1 2 21
2 4 46
2 6 25
3 4 34
3 5 15
4 5 40
4 6 51

def PRIM(start,V):  # G: 그래프, r: 시작 정점
	key = [inf] * (V + 1)
	key[start] = 0
	MST = [0] * (V+1)
	pi = [0] * (V+1)
	for _ in range(V):
		u = 0
		minV = inf
		for i in range(V+1):
			if MST[]
```





## KRUSKAL 알고리즘

* 간선을 하나씩 선택해서 `MST`를 찾는 알고리즘
  1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  3. n-1 개의 간선이 선택될 때까지 2를 반복

![image-20211218152624872](03_최소신장트리(MST).assets/image-20211218152624872.png)

![image-20211218152638491](03_최소신장트리(MST).assets/image-20211218152638491.png)

```
edge_lst = [
(51,0,6),
(31,0,2),
(25,2,6),
(32,0,1),
(21,1,2),
(46,2,4),
(51,6,4),
(60,0,5),
(18,5,3),
(34,3,4),
(40,5,4)]

def Find(a) :
    if parent[a] == a : return a
    ret = Find(parent[a])
    parent[a] = ret
    return ret

def Union(a,b):
    pa = Find(a)
    pb = Find(b)
    if pa!= pb :
        parent[pb] = pa
    return
    
#init
parent = [ i for i in range(7)]
edge_lst.sort()  # 오름차순으로 정렬되어 있어야 함

# --> 가중치가 작은 값부터 MST 에 포함시킨다 . 최종적으로는 모든 정점들이 하나의 그룹이 된다.
total_cost = 0
for edge in edge_lst :
    cost,a,b = edge
    # a, b가 같은 그룹인가 ?
    if Find(a) == Find(b) : continue
    # 같은그룹이 아니면 그룹을 맺기 + a-b 간선비용을 누적
    Union(a,b)
    total_cost += cost

print(total_cost)
```

