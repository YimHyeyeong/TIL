* 버블 정렬

  ```
  def BubbleSort(a):
  	for i in range(len(a)-1, 0, -1):
  		for j in range(0, i):
  			if a[j] > a[j+1]:
  				a[j], a[j+1] = a[j+1], a[j]
  ```

  

* 카운팅 정렬

  1. 빈 리스트의 인덱스에 해당하는 숫자들의 개수를 센다.
  2. 숫자들을 누적합한다. 
  3. 기존 리스트 맨 뒤의 숫자에 해당하는 인덱스를 찾아 -1한다. 
  4. -1한 숫자에 해당하는 인덱스에 숫자를 넣는다. 

  ```
  def Counting_Sort(A, B, k):
  # A[]: 입력 배열(1 to k)
  # B[]: 정렬된 배열
  # C[]: 카운트 배열
  
  	C = [0] * (k+1)
  	
  	for i in range(0, len(B 혹은 A #크기 자체는 둘이 같음)):
  		C[A[i]] += 1        #개수를 카운트
  		
  	for i in range(1, len(C)):
  		C[i] += C[i-1]
  	
  	for i in range(len(B)-1, -1, -1):
  		C[A[i]] -= 1
  		B[C[A[i]]] = A[i]
  ```

* 순열

  * nPr = n * (n-1) * (n-2) * ... * (n-r+1) 
  * nPn = n! = n * (n-1) * (n-2) * ... * 2 * 1

  ```
  {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
      for i1 in range(1, 4):
          for i2 in range(1, 4):
              if i2 != i1:
                  for i3 in range(1, 4):
                      if i3 != i1 and i3 != i2:
                          print(i1, i2, i3)
  ```

  ```
  [[0] * M for _ in range(N)]
  ```



* 행 우선 순회

  ```
  for i in range(len(Array)):
  	for j in range(len(Array[i]))
  		array[i][j]
  ```

* 열 우선 순회

  ```
  for j in range(len(Array[0])):
  	for i in range(len(Array)):
  		Array[i][j]
  ```

* 지그재그 순회

  ```
  for i in range(len(Array)):
  	for j in range(len(Array[0]))
  		Array[i][j + (m-1-2*j) * (i%2)]   # i가 홀수일 때 m-1-j가 되면 됨
  		
  혹은
  for i in range(N):
  	if i % 2 == 0:
  	~~~
  ```





* 델타이동

  ```
  dr = [-1, 1, 0, 0]
  dc = [0, 0, -1, 1]
  
  for r in range(N):
  	for c in range(M):
  		for i in range(4):
  			nr = r + dr[i]
      		nc = c + dc[i]
              if 0 <= nr < N and 0 <= nc < N:
                  print(arr[nr][nc])
  ```

  ```
  for r in range(N):
  	for c in range(M):
  		for dr,dc in [(0,1),(1,0),(0,-1),(-1,0)]:
  			nr = r + dr
      		nc = c + dc
      		if 0 <= nr < N and 0 <= nc < N:
                  print(arr[nr][nc])
  ```

  

* 전치 행렬

  ```
  # 3*3 행렬
  
  for i in range(3):
  	for j in range(3):
  		if i < j :
  		 arr[i][j] , arr[j][i] = arr[j][i], arr[i][j]
  ```

  

* 부분집합의 수 

  ```
  집합의 원소: n
  부분집합의 수: 2^n
  ```

* 부분집합 생성하기

  ```
  bit = [0, 0, 0, 0]
  arr = [1, 2, 3, 4]
  for i in range(2) :
  	bit[0] = i                  
  	for j in range(2) :
  		bit[1] = j              
  		for k in range(2) :
  			bit[2] = k          
  			for l in range(2) :
  				bit[3] = l      
  				print(*bit) 
                  # 각각의 어떤 원소가 들었는지 확인하려면
                  for p in range(4):
                  	if bit[p]
                  		print(arr[p],end=' ')
                  	print()
  ```





* << 연산자

  ```
  1 << n: 2^n = 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
  ```

* & 연산자

  ```
  i & (1<<j): i의 j번째 비트가 1인지 아닌지를 리턴한다. 
  ```

* 부분집합을 생성하는 간단한 방법

  ```
  n = len(arr)
  for i in range(1<<n): #부분집합의 개수
  	for j in range(n):  #원소의 수만큼 비트를 비교함
  		if i &(1<<j):        #i의 j번째 비트가 1이면 j번째 원소 출력
  			print(arr[j], end = ' ')
  	print()
  print()
  ```

  

* 순차 검색(정렬되어 있지 않은 경우)

  ```
  def search(a,n,key):
  	i = 0
  	while i < n and a[i] != key:    #순서가 바뀌면 안됨
  		i += 1
  	if i<n:      # 찾은 경우
  		return i
  	else:		# 못찾은 경우
  	 return -1
  	 
  def search(A,N,Key):
   for i in range(N):
   	if A[i] == Key:
   		return i
   return -1
  ```

  

* 순차 검색(정렬되어 있는 경우)

  ```
  def search(a,n,key):
  	i = 0
  	i += 1
  	while i<n and a[i]<key:
  		i += 1
  	if i<n and a[i] = key:
  		return i
  	else:
  		return -1
  		
  
  def search(A,N,Key):
  	for i in range(N):
  		if A[i] == Key:
  			return i
  		elif A[i] > Key:
  			return -1
  	return -1
  ```

  

* 이진 검색

  ```
  def search(a, key):
  	start = 0
  	end = len(a)-1
  	while start <= end:
  		middle = (start + end) // 2
  		if a[middle] == key:
  			return True
  		elif a[middle] > key:
  			end = middle - 1
  		else:
  			start = middle +1
  	return False
  ```

  

* 이진 검색(재귀 함수 이용)

  ```
  def search(a, low, high, key):
  	if low > high:
  		return False
  	else:
  		middle = (low + high) // 2
  		if key == a[middle]:
  			return True
  		elif key < a[middle]:
  			return search(a, low, middle-1, key)
  		elif a[middle] < key:
  			return search(a, middle+1, high, key)
  ```

  

* 선택 정렬 

  1. 리스트에서 최소값을 찾는다
  2. 리스트 맨 앞의 값과 교환한다
  3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 반복한다

  ```
  def sort(a):
  	for i in range(len(a)-1):
  		min = i
  		for j in range(i+1, len(a)):
  			if a[min] > a[j]
  				min = j
  		a[i], a[min] = a[min], a[i]
  ```

* 셀렉션 알고리즘

  * 자료로부터 K번째로 큰 혹은 작은 원소를 찾는 알고리즘

  ```
  def select(list, k):
  	for i in range(o,k):
  		minidx = i
  		for j in range(i+1, len(list)):
  			if list[minidx] > list[j]:
  				minidx = j
  		list[i], list[minidx] = list[minidx], list[i]
  	return list[k-1]
  ```

  

* 고지식한 알고리즘

  ```
  p = "is" #찾을 패턴
  t = "This is a book~!"
  M = len(p)
  N = len(t)
  
  def force(p,t):
  	i = 0 # t의 인덱스
  	j = 0 # p의 인덱스
  	while j < M and i < N:
  		if t[i] != p[j]:
  		 	i = i - j
  			j = -1
  		i = i + 1
  		j = j + 1
  	if j ==M:
  		return i - M #검색 성공
      else:
      	return -1
  ```

  ```
  for i in range(N-M):
  	for j in range(M-1):
  		if p[j] != t[j+j]
  			break
  		if j = M-1
  			return i
  return -1
  ```

* KMP 알고리즘

  ```
  next = [o] * M
  cnt = 0 #일치한 개수
  i = 1
  while i < M:
  	if p[i] == p[cnt]:
  		cnt += 1
  		next[i] = cnt
  		i += 1
  	else:
  		if cnt != 0:
  			cnt = next[cnt-1]
  		else:
  			next[i] = 0
  			i += 1
  
  ```

* 보이어-무어 알고리즘

  ```
  ```

  