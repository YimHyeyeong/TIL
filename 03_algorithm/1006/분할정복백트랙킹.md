## 분할 정복

* 거듭 제곱

```
def powe(x,n):
	if n==1: return x
	if n % 2 ==0:
		y = power(x,n/2)
		return y * y
	else:
		y = power(x,(n-1)/2)
		return y * y * x
```

* 병합 정렬

  * 자료를 최소 단위로 나눈 후에 차례대로 정렬하고 답을 구하는 과정

* 병합 정렬 과정

  * {69,10,30,2,16,8,31,22}
  * 분할 단계: 전체 자료 집합에 대하여 최소 크기의 부분 집합이 될 때까지 분할 작업을 계속한다.
    * 숫자 하나하나를 쪼갬
  * 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
    * 8개의 부분집합이 1개로 병합될 때까지 반복함
  * 분할 과정 알고리즘

  ```
  def sort(list_m):
  	if len(m) == 1 :return m
  	left = 
  	right = 
  	middle = len(m) / 2
  
  ```

  * 병합 과정 알고리즘

  ```
  def merge(left,right):
  	result = []
  	while len(left) > 0 or len(right) > 0:
  		if len(left) > and len(right) > 0:
  			if 
  	
  ```

* 퀵 정렬

  * 병합 정렬과 다른 점:
    1. 병합 정렬은 그냥 두 부분으로 나누는 반면에 퀵 정렬은 분할할 때 기준 아이템 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다
    2. 각 부분 정렬이 끝난 후 병합 정렬은 병합이란 후처리 작업이 필요하나 퀵 정렬은 필요로 하지 않는다.
  * 알고리즘

  ```
  def sort(A, l, r):
  	if l< r:
  		 s = patition(A,l,r)
  		 sort(A,l,s-1)
  		 sort(A,s+1,r)	
  ```

  * Hoare-Partition 알고리즘

  ```
  def partition(A, l, r):
  	p = A[l]  # p: 피봇 값
  	i , j = l, r
  	while i <= j:
  		while i <= j and A[i] <= p: 
  			i += 1
  		while i <= j andA[j] >= p : 
  			j -= 1
  		if i < j : 
  			A[i], A[j] = A[j], A[i]
  	A[l], A[j] = A[j], A[l]
  	return j
  ```

  * Lomuto partition 알고리즘

  ```
  def partition(A,p,r):
  	x = A[r] # 피봇
  	i = p -1
  	for j in (p, r):
  		if A[j] <= x:
  			i += 1
  			A[i], A[j] = A[j], A[i]
  	A[i+1],A[r] = A[r], A[i+1]
  	return i + 1
  ```

* 이진 검색

  * 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
  * 반복 구조 알고리즘

  ```
  def search(n, S, k):
  	low = 0
  	high = n -1
  	while low <= high:
  		mid = low + (high - low) / 2
  		if S[mid] == key:
  			return mid
  		elif S[mid] > key:
  			high = mid - 1
  		else:
  			low = mid + 1
  	return -1
  ```

  * 재귀 구조 알고리즘

  ```
  def search(S, low, high, key):
  	if low > high:
  		return -1
  	else:
  		mid = (low + high) / 2
  		if key == S[mid]:
  			return mid
  		elif key < S[mid]:
  			return search(S, low, mid -1, key)
  		else:
  			return search(S, mid+1, high, key)
  ```

  

## 백트래킹

* 백트래킹 개념
  * 당첨 리프 노드 찾기
    * 루트에서 갈 수 있는 노드를 선택한다
    * 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작한다
    * 더 이상의 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택을 한다
    * 루트까지 돌아갔을 경우 
* 백트래킹과 깊이 우선 턈색과의 차이
  * 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 출임( 가지치기)





## 트리

* 부모를 인덱스로 자식을 표시하는 건 순회할 때

* 자식인덱스로 부모를 표시한건 조상을 찾을때 : 값이 0이면 루트노드

  ```
  f(n):
  	if n:
  		visited(n)
  		f(left[n])
  		f(right[n])
  ```

  ```
  완전 이진 트리
  f(n)
  	if n < last:
          visited(n)
          f(n*2)
          f(n*2+1)
  ```

* 힙 연산 - 삽입

```
def enq(n):
	global last
	last += 1
	tree[last] = n
	c = last
	p = c//2
	while p >= 1 and tree[p] < tree[c]:
		tree[p], tree[c] = tree[c], tree[p]
		c = p
        p = c //2
        
def deq():
	global last
	tmp = tree[1]
	tree[1] = tree[last]
	last -= 1
	p = 1
	c1 = 2*p
	c2 = 2*p + 1
	while c1 <= last: # 자식이 하나라도 있으면
		if c2<= last: # 자식이 둘이면
			if tree[c1] >= tree[c2] and tree[c1] > tree[p]:
				tree[c1], tree[p] = tree[p], tree[c1]
				p = c1
			elif tree[c1]<tree[c2] and tree[c2]>tree[p]:
				tree[c2],tree[p] = tree[p], tree[c2]
				p = c2
			c1 = p * 2
			c2 = p*2+1
		else: # 왼쪽 자식만 있는 경우
			if tree[c1] > tree[p]:
				tree[c1], tree[p] = tree[p], tree[c1]
				break
	
	
		
tree = [0] * 101 # 최대 100번 노드까지, 최대힙
last = 0 # 마지막 노드 번호
a =  [7,2,3,9,5]
for x in a:
	enq(x)
```

