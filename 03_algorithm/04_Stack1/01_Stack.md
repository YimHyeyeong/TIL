## Stack

* 스택의 특성

  * 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다. 
  * 스택에 저장된 자료는 선형 구조를 갖는다.
    * 선형구조: 자료 간의 관계가 `1대1`의 관계를 갖는다.
    * 비선형구조: 자료 간의 관계가 `1대 N`의 관계를 갖는다. (예: 트리)
  * 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
  * 마지막에 삽입한 자료를 가장 먼저 꺼낸다. **후입선출**이라고 부른다. (`LIFO`, `Last-In-First-Out`)
    * 예를 들어 스택에 1,2,3순으로 자료를 삽입한 후 꺼내면 역순으로 즉 3,2,1 순으로 꺼낼 수 있다.

* 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산

  * 자료구조: 자료를 선형으로 저장할 저장소

    * 저장소 자체를 스택이라 부르기도 한다
    * 스택에서 마지막 삽입된 원소의 위치를 `top`이라 부른다.

  * 연산

    * 삽입: 저장소에 자료를 저장한다. 보통 `push`라고 부른다

    * 삭제: 저장소에서 자료를 꺼낸다, 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 `pop`이라고 부른다

    * 스택이 공백인지 아닌지를 확인하는 연산: `isEmpty`

      > 안에 들어있니? : !isEmpty()

    * 스택의 top에 있는 item(원소)을 반환(확인)하는 연산: `peek`

* 스택의 push 알고리즘

  * `Append` 메소드를 통해 리스트의 마지막에 데이터를 삽입

  ```
  s = []
  def push(item):
  	s.append(item)
  ```

* 스택의 pop 알고리즘

  ```
  def pop():
  	if len(s) == 0:    #여긴 디버깅 용도
  		# underflow    
  		return
  	else:
  		return s.pop(-1); #s.pop()해도 됨
  ```

  > 보통은 스택이 비었는지 먼저 확인하고 시작함. 스택이 비었지 않았다면 pop해라 라는 식의

* 구현한 스택을 이용하여 3개의 데이터를 스택에 저장하고 다시 3번 꺼내서 출력

  ```
  s = []
  s.append[1]
  s.append[2]
  s.append[3]
  print(s.pop()) 해도 되지만
  ```

  ```
  top = -1
  s = [0] * 10
  혹은 함수
  top += 1
  s[top] = 1
  ```

* 스택 안의 모든 걸 다 꺼낼 때

  ```
  while stack:
  	print(s.pop())
  ```

  ```
  while top >= 0:
  	top -= 1
  	print(s[top+1]) 
  	or
  	print(s[top])
  	top -= 1
  ```

* 스택 구현 고려 사항

  * 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기 어렵다는 단점이 있다. 
  * 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가진다.