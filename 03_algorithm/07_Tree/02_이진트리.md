## 이진 트리

* 이진 트리
  
  * 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
  
  * 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
    
    * 왼쪽 자식 노드
    
    * 오른쪼 자식 노드
      
      > 자식이 없어도 1개만 있어도 이진 트리됨

* 특성
  
  * 레벨 i 에서의 노드 최대 개수는 2^i개
  * 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며 최대 개수는 (2^(h+1) -1)개가 된다

* 이진 트리 - 종류
  
  * 포화 이진 트리
    
    * 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
    
    * 높이가 h일 때 최대의 노드 개수인 (2^(h+1) -1)의 노드를 가진 이진 트리
    
    * 루트를 1번으로 하여 2^(h+1) -1 까지 정해진 위치에 대한 노드 번호를 가짐
      
      > 포화에선 루트가 항상 1번임 다른 건 아닐 수도 있음
  
  * 완전 이진 트리
    
    * 높이가 h이고 노드 수가 n개 일때 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
  
  * 편향 이진 트리
    
    * 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
      
      * 왼쪽 편향 이진 트리
      
      * 오른쪽 편향 이진 트리
        
        > 순차 자료구조랑 같아짐

---

이진트리구현

```
# left , right

def dfs(now):
    if now == -1: return    # 값이 없는 걸 -1로 설정했으니까
    dfs(left[now])
    print(now, end=' ')
    dfs(right[now])
    return # 트레이스 편하게 하기 위함

left = [-1 for _ in range(9)]  # -1은 내 왼쪽에 아무것도 없다고 기본값을 설정
right = [-1 for _ in range(9)] # 9는 노드의 수

left[0] = 1
right[0] = 2
left[1] = 3
right[1] = 4
left[3] = 7
right[3] = 8
left[2] = 5
right[2] = 6

dfs(0)
```

```
# 인접 리스트

def dfs(now):


adj = [[-1,-1] for _ in range(9)]
adj[0][0] = 1
adj[0][1] = 2
adj[1][0] = 3
adj[1][1] = 4
adj[2][0] = 5
adj[2][1] = 6
adj[3][0] = 7
adj[3][1] = 8
```

```
# 인덱스
# 주의점 . 인덱스 초과

tree = ['#', 'A', 'B', 'C', 'D', 'E', '#', 'F', 'G', 'H']

def dfs(idx):
    if idx >= len(tree) : return
    if tree[idx] == '#': return

    dfs(idx *2) #왼쪽 자식
    print(tree[idx])
    dfs(idx * 2 + 1) # 오른쪽 자식

    return

dfs(1)
```
