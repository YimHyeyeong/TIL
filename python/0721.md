## 0721

---

### 함수기초

+ 특정한 기능을 하는 코드의 조각(묶음)

+ 하나의 큰 프로그램을 여러 부분으로 나누어 같은 함수를 여러 상황에서 호출하고(높은 재사용성), 일부분을 수정하기 쉽가(유지보수 용이)는 장점

+ 함수의 특징

  + 함수의 이름을 결정해야함
  + 매개변수가 들어감
  + 바디(boby)- 덕스트링과 코드셋이 들어감
  + 반환 값을 가짐

+ 함수를 사용해야하는 이유

  + pstdev
  + pow(a,b): a의 b제곱

+ 함수의 기본구조

  ```
  def pstdev(data, mu=None):
   """Return the squre root 
  ```

+ Docstring

  + 함수나 클래스의 설명 
  + print(함수이름.__ doc __)하면 덕스트링 나옴

+ 내장 함수

  + 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형(type)이 내장되어 있음

+ 함수의 선언 

  + 함수의 선언은 def 키워드를 활용함
  + 들어쓰기를 통해 함수 body(실행될 코드 블록)를 작성함
    + Docstring은 함수 body 앞에 선택적으로 작성 가능
      + 작성시에는 반드시 첫번째 문장에 문장열 ''' docstring '''
  + 함수에는 매개변수를 넘겨줄 수도 있음(설정한다 =변수 =박스/재료 =인자 argument)매개변수 없는하ㅁ수ㅗ잇음  인자는 매개변수에맞게넣어야함
  + 함수는 동작 후에 return을 통해 결과 값을 전달함
    + 반드시 하나의 객체를 반환

+ 함수의 호출

  + 함수는 함수면()으로 호출

    + 매개변수가 있는 경우, 함수면(값1, 값2 ...)로 호출

      ```
      def foo():
          return True
      ```

  + 함수의 선언과 호출 예시

    ```
    num1 = 0
    num2 = 1
    
    def func1(a, b):
    	return a + b
    def func2(a, b):
    	return a - b
    def func3(a, b):
    	return func
    ```

    + 함수는 호출되면 코드를 실행하고 return 값을 반환하면 종료된다.

+ 함수 실습 문제 - 세제곱 함수

  ```
  def cube(num):
  	return num ** 3
  
  print(cube(2))
  print(cube(100))
  ```





### 함수 output

+ 함수의 리턴(return)

  + 함수는 항상 반환되는 값이 있으며 어떠한 객체라도 상관없음

  + 오직 한 개의 객체만 return 됨

  + 복수의 객체를 return 하는 경우

    ```
    def foo(a, b):
     return a+b, a-b
    
    foo(1, 2)
    ```

  + 명시적인 return 값이 없는 경우

    ```
    def greeting():
    	print('hi')
    
    greeting()
    hi
    
    type(greeting())
    Nonetype - 명시적인 리턴이 없어서 none 나옴 하지만 하나의 객체를 반환한거임
    ```

  + return vs print

    + return은 함수 안에서만 사용되는 키워드
    + print는 출력을 위해 사용되는 함수
    + REPL(주피터노트북 같은거)환경에서는 마지막에 작성된 코드의 리턴 값을 보여주므로 같은 동작을 하는 것으로 착각할 수 있음

+ 함수의 실습문제 - 사각형 넓이

  + 너비와 높이를 입력 받아 사각형의 넓이와 둘레를 튜플로 반환하는 함수 rectangle을 작성하시오

    ```
    def rectangle(width, height):
    	area = width * height
    	perimeter = 2 * (width + height)
    	return area,perimeter
    print(rectangle(30,20))
    ```





### 함수 input

+ 위치 인자(positional Arguments) 

  + 아까는 파라미타였는데 지금은 왜 인자일까? 

    + parameter(매개변수): 함수에 입력으로 전달된 값을 받는 변수

      ```
      def my_func(a, b):
      	pass
      ```

    + argument(인자,인수): 함수를 호출할 때 함수에 전달하는 입력값

      ```
      my_func(1, 2)
      ```

      

  + 기본적으로 함수 호출 시 인자는 위치에 따라 함수 내에 전달됨

  + 위치는 소듕하게 무적권 1번

+ 기본 인자 값

  + 기본값을 지정하여 함수 호출 시 인자 값을 설정하지 않도록 함
    + 정의 된 것 보다 더 적은 개수의 인자들로 호출 될 수 있음
  + 위치인자 다음 기본인자 다음 가변

+ 키워드 인자

  + 직접 변수의 일음으로 특정 인자를 전달할 수 있음
  + 키워드 인자 다음에 위치 인자를 사용할 수 없음

+ 가변 인자 리스트

  + 함수가 임의의 개수 인자로 호출될 수 있도록 지정

  + 인자들은 튜플로 묶여 처리되며 매개변수에 *을 붙여 표현

  + 튜플 형태로 인자를 받음

  + 최대한 우측사이드에 위치하도록 해야 함. 마지막에 위치하도록

  + ```
    def add(*args):    args: 이름 바꿔도 되지만 관습적으로 이거씀 그냥 매개변수이름임
    	for arg in args(이거 튜플임):
    		print(arg)
    		
    add(2)
    add(2,3,4,5) - 이려면 ((2,3), (4,5)) 튜플로 묶임
    ```

+ 가변 키워드 인자

  + 함수가 임의의 개수 인자를 키워드 인자로 호출될 수 있도록 지정

  + 인자들은 딕셔너리로 묶여 처리되며 매개변수에 **를 붙여 표현

  + 키워드 인자 갯수를 모를 때 사용

    ```
    def family(**kwargs):
    	for key, value in kwargs:
    	print(key,)
    ```

+ 함수 정의 주의사함

  + 기본 인자 값을 가지는 인자 다음에 기본 값이 없는 인자로 정의할 수 없음
    + SytaxError: no- default argument follows default argument
    + 예를 들어 greeting(40)하면 첫 번째 위치인자로 들어가버림 하지만 매칭이 안됨.

+ 함수 호출 주의 사함

  + 키워드 인자 다음에  위치 인자를 활용할  수 없음

  + 가변 인자리스트가 위치 이니자보다 앞쪽에 올 수 없음

    ```
    add(*args, x)
     add(1,2,3)-어디까지가 가변인자인지 모름 x를 찾지 못함 가변인자는 뒤로 가야함
    ```

  + typeError

  + 가변 키워드 인자가 위치 인자보다 앞쪽에 올 수 없음 애초에 선언이 안됨

    ```
    ```

  + 좋은 구조

    ```
    my_info(x, y, *args, **kwargs)
    ```





### 함수 scope

+ 함수 스코프

  + 함수는 코드 내부에 지역 스코프를 생성하면 그 외의 공간인 전역 스코프로 구분

  + 함수만 스코프를 가짐. if나 for도 스코프를 가지지 않음.

  + 스코프

    + 전역 스코프: 코드 어디에서든 참조할 수 있는 공간

    + 지역 스코프: 함수가 만든 스코프/ 함수 내부에서만 참조 가능

      ```
      def func()
      	pass - 요런 스코프? 
      ```

  + 변수

    + 전역 변수: 전역 스코프에 정의된 변수

      지역 변수: 지역 스코프에 정의된 변수

+ 변수 수명주기

  + 변수는 각자의 수명주기가 존재

    + 빌트인 스코프
      + 파이썬이 실행된 이후부터 영원히 유지
    + 전역 스코프
      + 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날때까지 유지 (import 어쩌구 어쩌구가 모듈?)
    + 지역 스코프 
      + 함수가 호출될 때 생성되고 함수가 종료될 때

  + 함수 스코프 예시

    ```
    def func():
    	a = 20
    	print('local', a)
    func()
    print('gloal',a)
    
    a는 함수 내에서 할당 되었으므로 지역 스코프에서만 존재 함수가 종료되며 사라짐
    ```

+ 이름 검색 규칙

  + 파이썬에서 사용되는 이름(식별자)들은 이름공간에 저장되러있음
  + 다음 순서로 이름을 찾아 나감 LEGB Rule라고 부름
    + Local scope: 함수
    + Enclosed scope : 특정 함수의 상위 함수
    + Global scop: 함수 밖의 변수 inport 모듈
    + Built-in scope : 파이썬 안에 내장되어 있는 함수 또는 ㅗㄱ성
  + 즉 함수 내에서는 바깥 스코프의 변수에 접근 가능하나 수정은 할수 없음

+ global

  + 현재 코드 블록 전체에 적용되며 나열된 식별자(이름)들이 전역 변수 임을 나타냄
    + global에 나열된 이름은 같은 코드 블록에서 global 앞에 등ㄷ장할수없음
    + global에 나열된 이름은 매개 변수 for 루프대상 클래스.함수 정의등으로 정의되지 않아야 함

+ nonlocal

  + 전역을 제외하고 가장 가까운 (둘러 싸고 있는) 스코프의 변수를 연결하도록 함
    + nonlocal에 나열된 이름은
    + nonlocal은 이름공간 상에 존재하는 변수만 가능

+ 주의

  + 기본적으로 함수에서 선언된 변수는 local scope에 생성되며 함수 종료 시 사라짐
  + 해당 스코프에 변수가 없는 경우 LEGB rule에 의해 이름을 ㅅ검색함
    + 변수에 접근은 가능하지만 해당 변수를 수정할 수는 없음
    + 값을 할당하는 경우 해당 스코프의 이름공간에 새롭게 생성되기 때문
    + 단 함수 내에서 필요한 상위 스코프 변수는 인자로 넘겨서 활용할것 (클로저 제외- 클로저란 어떤 함수 내부에 중첩된 형태로써 외부 스코프 변수에 접근 가능한 함수)
  + 상위 스코프에 있는 변수를 수정하고 싶다면 global, nonlocal 키워드를 활용 가능
    + 단 코드가 복잡해지면서 변수의 변경을 추적하기 어렵고 예기치 못한 오류가 발생
    + 가급적 사용하지 않는 것을 권장하며 함수로 값을 바꾸고자 한다면 항상 입자로 넘기고 리턴 값을 사용하는 것을 추천 





### 재귀함수

+ 자기 자긴을 호출하는 함수

+ 팩토리얼 실습

+ ``` 
  def fact(n):
  	result = 1 (곱셈이라서 1 0이면 안됨)
  	while n >1:
  		result *= n
  		n -= 1
  	return result
  		
  ```

+ 재귀함수로 팩토리얼 실습

+ ```
  det factorial(n):
  	if n ==1:    #얘가 basecase
  		return n
  	else:
  		return n * factorial(n-1)
  print(factorlal(4))
  ```

+ 팩토리얼 - 재귀 함수

  + 반복문
    + n이 1보다 큰 경우 반복문 실핼, n은 1씩 감소
    + 마지막에 n이 1이면 더 이상 반복문을 돌지 않음

+ 재귀 함수 주의 사항

  + 재귀 함수는 base case에 도달할 때까지 함수를 호출함
  + 메모리 스택이 넘치게 되면(stack overflow) 프로그램이 동작하지 않게 됨
  + 파이썬에서는 최대 재귀 깊이가 1000번으로호출 횟수가 이를 넘어가게 되면 Recursion Error 이 발생함

+ 재귀 함수 실습 문제

  + 피보나치 수열을 계산하는 함수를 반복문과 재귀 함수를 활용하여 작성하시오

    + 피보나치수열:  1, 1, 2, 3, 5 다음 항은 앞의 두 항의 항 인덱스 0은 0임 별로 소용이 없어서 생략

  + ```
    #재귀
    def fib(n):
    	#base case는 1?
    	if n <2:
    		return n
    	else:
    		return fib(n-1) + fib(n-2)
    		
    #반복문
    def fib(n):
    	if n < 2:
    		return n
    	a b = 0, 1
    	for i in range(n-1):
    		a, b = b, a+b
    	return b 
    print(fib(4))
    ```





### 에러

+ 디버깅 
  + print 문 활용
    + 특정 함수 결과, 반복/ 조건 결과 등 나눠서 생각
  + 개발 환경 등에서 제공하는 기능 활용
    + breakpoint, 변수 조회등
+ 에러 메시지가 발생하는 경우
  + 해당 하는 위치를 찾아 메시지를 해결
+ 로직 에러가 발생하는 경우
  + 명시적인 에러 메시지 없이 예상과 다른 결과가 나온 경우
+ 문법 에러
  + SyntaxError가 발생하면 파이썬 프로그램이 실행 되지 않음
  + 파일이름, 줄 번호, ^ 문자를 통해 파이썬이 코드를 읽어 나갈 때(parser)문제가 발생한 위치를 표현
  + 줄에서 에러가 감지된 가장 앞의 
  + Invalid syntax 문법 자체가 틀림/ assign to literal 값이 잘못 할당됨 / EOL /EOF



### 예외

+ 예외

  + 실행 도중 예상치 못한 상황을 맞이하면 프로그램 실행을 멈춤
    + 문장이나 표현식이 문법적으로 올바르더라도 발생하는 에러
  + 실행 중에 감지되는 에러들을 예외라고 부름
  + 예외는 여러 타입으로 나타나고 타입이 메시지의 일부로 출력됨
    + NameError, typeError 등 발생한 예외 타입의 종류(이름)
  + 모든 내장 예외는 Exception Class를 상속받아 이뤄짐
  + 사용자 정의 예외를 만들어 관리할 수 있음
  + ZeroDivisionError: 0으로 나누고자 할 때 발생 / NameError: namespace 상에 이름이 없는 경우 / typeError : 타입 불일치, argument 누락, 개수 초과,  argument type 불일치/ valueError: 타입은 올바르나 값이 적절하지 않거나 없는 경우/ indexerror: 인덱스가 존재하지 않거나 범위를 벗어나는 경우/ keyerror: 해당 키가 존재하지 않는 경우/ modulnotfounderror: 존재하지 않는 모듈을 inport하는 경우/ importerror: 모듈을 있으나 존재하지 않는 클래스/ 함수를 가져오는 경우/Keyboardinterrupt:임의로 프로그램을 종료하였을 때/ indentationerror: indentation이 적절하지 않은 경우

+ 예외 처리

  + try문 / except절을 이용하여 예외 처리할 수 있음

  + try 아래의 코드 블록이 실행됨

    + 예외가 발생하지 않으면 except 없이 실행 종료
    + 예외가 발생하면 except 실행
    + except: (어떤 에러가 나도 반응)/ except valueerror: (valueerror이 나오면 반응)

  + 복수의 예외 처리 실습

  + ```
    num = input('100으론 나눌 값을 입력하시오')
    print(100/int(num))
    #문자,0을 입력하는 경우 오류 발생
    except valueerror
    
    #except exception - 이걸 맨 위에 있으면 모든 에러를 다 포함하고 있기 때문에 밑에 있는 except절은 절대 실행되지 않음 저게 가장 큰 범주이기 때문 작은 범주부터 써야함 
    ```

  + 예외 처리 종합

    + try: 코드를 실행함
    + except: try문에서 예외가 발생 시 실행함
    + else :try문에서 예외가 발생하지 않으면 실행함
    + finally: 예외 발생 여부와 상관없이 실행

  + 에러 메시지 처리

    + as 키워드를 활용하여 원본 에러 메시지를 사용할 수 있음
      + 예외를 다른 이름에 대입: 예외 안의 메시지를 직접 커스텀해서 사용할 수 있는거

+ 예외 발생 시키기

  + raise statement를 통해 예외를 강제로 발생
    + raise <표현식> (메시지)
  + assert를 통해 예외를 강제로 발생
    + assert는 상태를 검증하는데 사용되며 무조건 assertionerror가 발생
    + 일반적으로 디버깅 용도로 사용
    + 

EAFP예외처리를 활용하여 검사를 수행하지 않고 일단 실행하고 예외처리를 진행하는 스타일 .파이썬 코드가 문제없이 실행될것을 전제로 코드를  실행

my_dict = {'key':'value'}

try:

x = my_dict['key']

if 는 조건과 조건이 만족되면 실행

try는 그냥 실행 try를 사용하는 것이 더 좋다

LBYL은 if 스타일 도약하기 전에 봐라 어떤 것이 실행하기 전에 에러가 날만한 요소들을 조건문으로 검사를 하고 수행 
